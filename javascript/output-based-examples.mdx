---
title: Output Based Examples
description: "This document contains output based examples with javascript"
---

<img alt="Hero Dark" classname="hidden dark:block" src="https://www.tutorialrepublic.com/lib/images/javascript-illustration.png" />

## Problem 1

Using .then() with Promise.resolve()

### Program

```javascript
Promise.resolve("data").then((result) => {
  console.log(result);
});
console.log("Sync Code"); 
```

### Output

```
Sync Code
data
```

### Explanation

When you use .then(), the JavaScript engine does the following:

1. Register a Callback:

   * .then() attaches a callback function to a Promise.

   * This callback is scheduled to execute when the Promise is resolved.

2. Execution in the Event Loop:

   * Once the Promise resolves, the callback is queued in the microtask queue.

   * The JavaScript engine completes the current call stack, then processes tasks in the microtask queue before moving to the macrotask queue.

## Problem 2

Using await with Promise.resolve()

### Program

```javascript
async function example() {
  console.log("Before await");
  const result = await Promise.resolve("data");
  console.log(result);
}
example();
console.log("Sync Code");
```

### Output

```
Before await
Sync Code
data
```

### Explanation

When the JavaScript engine encounters await:

1. Pause Execution:

   * The await keyword pauses the execution of the function it is in until the Promise is resolved or rejected.

   * The function is split into “before await” and “after await.”

   * I takes the code after await and queue it to the microtask queue(but in a deferred state) which will only be resumed only when the Promise resolves or rejects.

2. Return Control to the Event Loop:

   * While waiting for the Promise, the function’s execution is suspended, and the JavaScript engine moves to the next task in the call stack.

3. Resume Execution:

   * Once the Promise is resolved, the engine schedules the rest of the async function (after await) as a microtask.

   * Execution continues from where it was paused.

## Problem 3

Using IIFE, async, await, Promise, setTimeout together

### Program

```javascript
const slowFunction = () => {
    console.log("Starts Slow Function");
    return Promise(res => {
        console.log("Promise Created")
        setTimeout(() => {
            console.log("Calling SetTimeout")
            res()
        }, 500);
        console.log("Promise Completed")
    })
}

(async () => {
    console.log("Inside IIFE");
    await slowFunction()
    .then(() => console.log("Then block"))
    .catch(() => console.log("Catch Block"))
    .finally(() => console.log("Finally Block"))
    
    console.log("Completed Calling slowFunction")
})()

console.log("Main")
```

### Output

```
Inside IIFE
Starts Slow Function
Promise Created
Promise Completed
Main
Calling SetTimeout
Then block
Finally Block
Completed Calling slowFunction
```

### Explanation

* As soon as we see and IIFE (Immediately Invoked Function Execution), we may think JS is going to treat in a special way, but I am really sorry it is not going to do that

  * An IIFE is a way to efficiently define and call a function without the use of any variables and deal with any kind of variable conflicts or come up with a very attractive name for the function (e.g., function toAddTwoNumberIfTheyAreEvenElseReturnFirst() \{} 🤯)

  *